/*
Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern

Тип: 		Поведенческий
Уровень: 	Объектный

Паттерн Chain Of Responsibility позволяет избежать привязки объекта-отправителя запроса к объекту-получателю запроса,
при этом давая шанс обработать этот запрос нескольким объектам. Получатели связываются в цепочку, и запрос передается
по цепочке, пока не будет обработан каким-то объектом.

По сути это цепочка обработчиков, которые по очереди получают запрос, а затем решают, обрабатывать его или нет.
Если запрос не обработан, то он передается дальше по цепочке. Если же он обработан, то паттерн сам решает
передавать его дальше или нет. Если запрос не обработан ни одним обработчиком, то он просто теряется.

Требуется для реализации:
1. Базовый абстрактный класс Handler, описывающий интерфейс обработчиков в цепочки;
2. Класс ConcreteHandlerA, реализующий конкретный обработчик A;
3. Класс ConcreteHandlerB, реализующий конкретный обработчик B;
4. Класс ConcreteHandlerC, реализующий конкретный обработчик C;

Обратите внимание, что вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит
единственную ссылку на начало цепочки, а каждый получатель имеет единственную ссылку на своего преемника - последующий
элемент в цепочке.
*/
package main

// Предположим, у нас есть система обработки текстовых сообщений, где каждое сообщение проходит через цепочку
// обработчиков для выполнения различных операций над текстом.

var isSpellingCorrect bool = true

// Определим интерфейс обработчика сообщений:
type MessageHandler interface {
	SetNext(handler MessageHandler)
	Handle(message string) string
}

// Реализуем конкретные обработчики сообщений
type SpellCheckHandler struct {
	next MessageHandler
}

func (h SpellCheckHandler) SetNext(handler MessageHandler) {
	h.next = handler
}

func (h SpellCheckHandler) Handle(message string) string {
	if isSpellingCorrect {
		return message
	} else if h.next != nil {
		return h.next.Handle(message)
	}
	return message
}

func main() {

}
