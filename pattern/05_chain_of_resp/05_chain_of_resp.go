/*
Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern

Тип: 		Поведенческий
Уровень: 	Объектный

Паттерн Chain Of Responsibility позволяет избежать привязки объекта-отправителя запроса к объекту-получателю запроса,
при этом давая шанс обработать этот запрос нескольким объектам. Получатели связываются в цепочку, и запрос передается
по цепочке, пока не будет обработан каким-то объектом.

По сути это цепочка обработчиков, которые по очереди получают запрос, а затем решают, обрабатывать его или нет.
Если запрос не обработан, то он передается дальше по цепочке. Если же он обработан, то паттерн сам решает
передавать его дальше или нет. Если запрос не обработан ни одним обработчиком, то он просто теряется.

Требуется для реализации:
1. Базовый абстрактный класс Handler, описывающий интерфейс обработчиков в цепочки;
2. Класс ConcreteHandlerA, реализующий конкретный обработчик A;
3. Класс ConcreteHandlerB, реализующий конкретный обработчик B;
4. Класс ConcreteHandlerC, реализующий конкретный обработчик C;

Обратите внимание, что вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит
единственную ссылку на начало цепочки, а каждый получатель имеет единственную ссылку на своего преемника - последующий
элемент в цепочке.

Применимость паттерна:
  - Когда имеется более одного объекта, который может обработать запрос, и система должна автоматически определить,
    какой объект должен обработать запрос.
  - Когда набор объектов, способных обработать запрос, должен быть определен динамически.
  - Когда необходимо отправить запрос нескольким объектам без явного указания получателя.

Плюсы паттерна:
  - Уменьшает зависимость между отправителем запроса и его получателем, так как отправитель не знает, кто будет
    обрабатывать запросы и какие объекты находятся в цепочке.
  - Позволяет гибко настраивать и изменять порядок обработки запросов в цепочке.
  - Упрощает добавление новых обработчиков в цепочку без изменения существующего кода.

Минусы паттерна:
- Запрос может быть не обработан, если достигнут конец цепочки и ни один из обработчиков не смог его обработать.
- Запрос может быть обработан несколькими обработчиками, что может привести к нежелательным или непредсказуемым результатам.

Реальные примеры использования паттерна "цепочка вызовов" включают:
- Обработка событий в пользовательских интерфейсах, где каждый элемент интерфейса может обрабатывать событие по своей логике.
- Фильтры веб-приложений, где каждый фильтр может обрабатывать запрос и передавать его следующему фильтру в цепочке.
- Логирование, где каждый логгер может обрабатывать сообщение и передавать его следующему логгеру в цепочке для записи в разные источники.
*/
package main

import "fmt"

// Предположим, у нас есть система обработки текстовых сообщений, где каждое сообщение проходит через цепочку
// обработчиков для выполнения различных операций над текстом.

var isSpellingCorrect bool = true
var isProfanity bool = true

// Определим интерфейс обработчика сообщений:
type MessageHandler interface {
	SetNext(handler MessageHandler)
	Handle(message string) string
}

// Реализуем конкретные обработчики сообщений

// Проверка орфографии
type SpellCheckHandler struct {
	next MessageHandler
}

func (h *SpellCheckHandler) SetNext(handler MessageHandler) {
	h.next = handler
}

func (h *SpellCheckHandler) Handle(message string) string {
	if isSpellingCorrect {
		fmt.Println("Spelling is correct")
		return message
	} else if h.next != nil {
		fmt.Println("Spelling is not correct and no last handler")
		return h.next.Handle(message)
	}
	fmt.Println("Spelling is not correct and last handler")
	return message
}

// Проверка ненормативной лексики
type ProfanityFilterHandler struct {
	next MessageHandler
}

func (h *ProfanityFilterHandler) SetNext(handler MessageHandler) {
	h.next = handler
}

func (h *ProfanityFilterHandler) Handle(message string) string {
	if isProfanity {
		fmt.Println("Profanity is correct")
		return message
	} else if h.next != nil {
		fmt.Println("Profanity is not correct and no last handler")
		return h.next.Handle(message)
	}
	fmt.Println("Profanity is not correct and last handler")
	return message
}

func main() {
	isSpellingCorrect = false
	isProfanity = true
	s := &SpellCheckHandler{}
	p := &ProfanityFilterHandler{}

	s.SetNext(p)

	message := "Test message!"

	processedMessage := s.Handle(message)

	fmt.Println(processedMessage)
}
